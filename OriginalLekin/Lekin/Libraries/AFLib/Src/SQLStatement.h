#pragma once

#include "AFLibArrays.h"
#include "AFLibStringBuffer.h"
#include "AFLibStringParser.h"

namespace AFLibDB {
class CDatabaseAF;
class CRecordsetAF;
class CColumn;
}  // namespace AFLibDB

namespace AFLibGui {
class CDlgRun;
}

/////////////////////////////////////////////////////////////////////////////
// TSQLStatement class -- encloses all ODBC/BCP data.
// Used for executing queries in CRecordsetAF and CDatabaseAF

namespace AFLibPrivate {
class TSQLStatement
{
private:
    bool m_bReadMsg;       // read messages?
    CString m_query;       // query to execute
    bool m_bAsyncStarted;  // async flag was set (needs to be cleared)

    // throw CDBException
    void PrivateThrow();

    // set the bulk size used in subsequent ODBC operations
    void SetBulk(int nBulk);

    // read all messages generated by SQL statement
    void ReadMsg();

    // helper for Open() and OpenExec()
    void PrivateOpen(LPCTSTR query, bool bExec, bool bForBulkODBC);

    // after an SQL operation, check error code and "break" status; maybe read messages
    bool PrivateEndSQO(bool bReadMsg);

    // turn asynchronous execution on or off
    void SetAsyncAttr(bool bOn);

    // we need asynchronous execution to display messages
    bool IsAsyncNeeded();

    // asynchronous execution of an SQL operation
    bool AsyncSQO(SQLRETURN (TSQLStatement::*F)());

    // *** operations executed under AsyncSQO
    SQLRETURN SQOExecDirect();
    SQLRETURN SQOFetch();
    SQLRETURN SQOBulkAdd();

    // parser for diagnostic messages
    class TStringParserEx : public AFLibIO::TStringParser
    {
    private:
        typedef AFLibIO::TStringParser super;

    public:
        TStringParserEx(LPCTSTR sPtr);

        // read message prefix; returns false if no more prefixes
        bool ReadPrefix(AFLibIO::TStringBuffer& sDest);

        // read the rest of the message
        void ReadMsg(AFLibIO::TStringBuffer& sDest);
    };

public:
    // diagnostic message prefixes: "vendor", "ODBC component identifier", and "data source"
    enum TMsgPrefix
    {
        mspVendor,
        mspDriver,
        mspSource,
        mspN
    };

    AFLibDB::CRecordsetAF* m_pRs;                      // recordset
    AFLibDB::CDatabaseAF* m_pDB;                       // database
    int m_nBulk;                                       // number of rows read in one bulk
    SQLHSTMT m_hstmt;                                  // open SQL statement
    SQLUSMALLINT* m_pRowStatus;                        // row status array
    SQLUINTEGER m_nRowsFetched;                        // number of rows fetched in the last operation
    SQLRETURN m_retCode;                               // return code from SQL operation
    AFLib::CConstArray<AFLibDB::CColumn> m_arrColSrc;  // for Bulk Insert: source columns

    AFLibGui::CDlgRun* m_pDlgRun;                 // dialog box to send messages to
    AFLibIO::TStringBuffer m_logMsg;              // messages generated by SQL
    AFLibIO::TStringBuffer m_arrMsgPrefix[mspN];  // prefixes of the last message

    TSQLStatement(AFLibDB::CDatabaseAF* pDB, bool bReadMsg);
    ~TSQLStatement();

    // open SQL Statement for reading a recordset or bulk writing
    void Open(AFLibDB::CRecordsetAF* pRs, bool bForBulkODBC);

    // execute SQL Statement (results are ignored)
    void OpenExec(LPCTSTR query);

    // close all handles
    void Close();

    // prepare for binding: bind status rows, etc.
    void Bind();

    // for the last bulk write, reduce batch size
    void ReduceBulk(int nBulk);

    // start "asynchronous" fetching or bulk-adding
    void StartAsync();

    // fetch more rows
    bool Fetch();

    // call the bulk-add SQL operation
    void BulkAdd();

    // get the number of columns in the last result set
    int CountColumns();

    // end SQL operation (check return codes, read messages)
    void EndSQO();

    // check return code after BCP operation, throw exception if error
    void ThrowBCP();
};
}  // namespace AFLibPrivate
